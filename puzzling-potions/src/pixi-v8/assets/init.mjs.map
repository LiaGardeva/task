{"version":3,"file":"init.mjs","sources":["../../src/assets/init.ts"],"sourcesContent":["import { extensions, ExtensionType } from '../extensions/Extensions';\nimport { bitmapFontCachePlugin, xmlBitmapFontLoader } from '../rendering/text/bitmap/asset/loadBitmapFont';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray';\nimport { detectAvif } from './detections/parsers/detectAvif';\nimport { detectDefaults } from './detections/parsers/detectDefaults';\nimport { detectMp4 } from './detections/parsers/detectMp4';\nimport { detectOgv } from './detections/parsers/detectOgv';\nimport { detectWebm } from './detections/parsers/detectWebm';\nimport { detectWebp } from './detections/parsers/detectWebp';\nimport { loadJson } from './loader/parsers/loadJson';\nimport { loadTxt } from './loader/parsers/loadTxt';\nimport { loadWebFont } from './loader/parsers/loadWebFont';\nimport { loadSvg } from './loader/parsers/textures/loadSVG';\nimport { loadTextures } from './loader/parsers/textures/loadTextures';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl';\n\nimport type { AssetExtension } from './AssetExtension';\n\nextensions.add(\n    cacheTextureArray,\n\n    detectDefaults,\n    detectAvif,\n    detectWebp,\n    detectMp4,\n    detectOgv,\n    detectWebm,\n\n    loadJson,\n    loadTxt,\n    loadWebFont,\n    loadSvg,\n    loadTextures,\n\n    resolveTextureUrl,\n\n    // TODO: these should probably be moved to its own init, along with splitting out all the\n    // text pipeline stuff\n    xmlBitmapFontLoader,\n    bitmapFontCachePlugin\n);\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAkBA,UAAW,CAAA,GAAA;AAAA,EACP,iBAAA;AAAA,EAEA,cAAA;AAAA,EACA,UAAA;AAAA,EACA,UAAA;AAAA,EACA,SAAA;AAAA,EACA,SAAA;AAAA,EACA,UAAA;AAAA,EAEA,QAAA;AAAA,EACA,OAAA;AAAA,EACA,WAAA;AAAA,EACA,OAAA;AAAA,EACA,YAAA;AAAA,EAEA,iBAAA;AAAA;AAAA;AAAA,EAIA,mBAAA;AAAA,EACA,qBAAA;AACJ,CAAA,CAAA;AAEA,MAAM,WAAc,GAAA;AAAA,EAChB,QAAQ,aAAc,CAAA,UAAA;AAAA,EACtB,UAAU,aAAc,CAAA,aAAA;AAAA,EACxB,OAAO,aAAc,CAAA,WAAA;AAAA,EACrB,WAAW,aAAc,CAAA,eAAA;AAC7B,CAAA,CAAA;AAMA,UAAA,CAAW,MAAO,CAAA,aAAA,CAAc,KAAO,EAAA,CAAC,SACxC,KAAA;AACI,EAAA,MAAM,MAAM,SAAU,CAAA,GAAA,CAAA;AAEtB,EAAO,MAAA,CAAA,OAAA,CAAQ,WAAW,CACrB,CAAA,MAAA,CAAO,CAAC,CAAC,GAAG,CAAM,KAAA,CAAC,CAAC,GAAA,CAAI,GAAgB,CAAC,CAAA,CACzC,QAAQ,CAAC,CAAC,KAAK,IAAI,CAAA,KAAM,UAAW,CAAA,GAAA,CAAI,MAAO,CAAA,MAAA;AAAA,IAC5C,IAAI,GAAgB,CAAA;AAAA;AAAA;AAAA,IAGpB,EAAE,SAAW,EAAA,GAAA,CAAI,GAAgB,CAAA,CAAE,aAAa,IAAK,EAAA;AAAA,GACxD,CAAC,CAAA,CAAA;AACV,CAAA,EAAG,CAAC,SACJ,KAAA;AACI,EAAA,MAAM,MAAM,SAAU,CAAA,GAAA,CAAA;AAEtB,EAAO,MAAA,CAAA,IAAA,CAAK,WAAW,CAClB,CAAA,MAAA,CAAO,CAAC,GAAQ,KAAA,CAAC,CAAC,GAAI,CAAA,GAAgB,CAAC,CACvC,CAAA,OAAA,CAAQ,CAAC,GAAQ,KAAA,UAAA,CAAW,OAAO,GAAI,CAAA,GAAgB,CAAC,CAAC,CAAA,CAAA;AAClE,CAAC,CAAA"}