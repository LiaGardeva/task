'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var source = "struct GlobalUniforms {\n    projectionMatrix:mat3x3<f32>,\n    worldTransformMatrix:mat3x3<f32>,\n    worldAlpha: f32\n}\n\nstruct GlobalFilterUniforms {\n    inputSize:vec4<f32>,\n    inputPixel:vec4<f32>,\n    inputClamp:vec4<f32>,\n    outputFrame:vec4<f32>,\n    backgroundFrame:vec4<f32>,\n    globalFrame:vec4<f32>,\n};\n\nstruct ShockWaveUniforms {\n    uTime: f32,\n    uOffset: vec2<f32>,\n    uSpeed: f32,\n    uWave: vec4<f32>,\n};\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n@group(1) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(1) @binding(1) var myTexture: texture_2d<f32>;\n@group(1) @binding(2) var mySampler : sampler;\n@group(1) @binding(3) var backTexture: texture_2d<f32>;\n@group(2) @binding(0) var<uniform> shockwaveUniforms : ShockWaveUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) backgroundUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;\n    return vec4((globalUniforms.projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);\n}\n\nfn filterBackgroundTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * gfu.backgroundFrame.zw;\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  \n}\nfn getSize() -> vec2<f32>\n{\n    return gfu.globalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n    @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n    return VSOutput(\n        filterVertexPosition(aPosition),\n        filterTextureCoord(aPosition),\n        filterBackgroundTextureCoord(aPosition),\n    );\n}\n\n@fragment\nfn mainFragment(\n    @location(0) uv: vec2<f32>,\n    @location(1) backgroundUv: vec2<f32>,\n    @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    let uTime = shockwaveUniforms.uTime;\n    let uOffset = shockwaveUniforms.uOffset;\n    let uSpeed = shockwaveUniforms.uSpeed;\n    let uAmplitude = shockwaveUniforms.uWave[0];\n    let uWavelength = shockwaveUniforms.uWave[1];\n    let uBrightness = shockwaveUniforms.uWave[2];\n    let uRadius = shockwaveUniforms.uWave[3];\n    let halfWavelength: f32 = uWavelength * 0.5 / gfu.inputSize.x;\n    let maxRadius: f32 = uRadius / gfu.inputSize.x;\n    let currentRadius: f32 = uTime * uSpeed / gfu.inputSize.x;\n    var fade: f32 = 1.0;\n    var returnColorOnly: bool = false;\n    \n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            returnColorOnly = true;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n    var dir: vec2<f32> = vec2<f32>(uv - uOffset / gfu.inputSize.xy);\n    dir.y *= gfu.inputSize.y / gfu.inputSize.x;\n\n    let dist:f32 = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        returnColorOnly = true;\n    }\n\n    let diffUV: vec2<f32> = normalize(dir);\n    let diff: f32 = (dist - currentRadius) / halfWavelength;\n    let p: f32 = 1.0 - pow(abs(diff), 2.0);\n    let powDiff: f32 = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\n    let offset: vec2<f32> = diffUV * powDiff / gfu.inputSize.xy;\n    // Do clamp :\n    let coord: vec2<f32> = uv + offset;\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.inputClamp.xy, gfu.inputClamp.zw);\n\n    var clampedColor: vec4<f32> = textureSample(myTexture, mySampler, clampedCoord);\n    \n    if (boolVec2(coord, clampedCoord)) \n    {\n        clampedColor *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n    // No clamp :\n    return select(clampedColor * vec4<f32>(vec3<f32>(1.0 + (uBrightness - 1.0) * p * fade), clampedColor.a), textureSample(myTexture, mySampler, uv), returnColorOnly);\n}\n\nfn boolVec2(x: vec2<f32>, y: vec2<f32>) -> bool\n{\n    if (x.x == y.x && x.y == y.y)\n    {\n        return true;\n    }\n    \n    return false;\n}\n\nconst PI: f32 = 3.14159265358979323846264;\n";

exports["default"] = source;
//# sourceMappingURL=shockwave.js.map
