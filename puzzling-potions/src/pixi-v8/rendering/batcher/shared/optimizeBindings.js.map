{"version":3,"file":"optimizeBindings.js","sources":["../../../../src/rendering/batcher/shared/optimizeBindings.ts"],"sourcesContent":["import type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\nimport type { TextureBatch } from './Batcher';\n\nexport const missing: TextureSource[] = [];\nexport let missingCount = 0;\n\nexport const currentCopy: TextureSource[] = [];\nexport let currentCount = 0;\n\nexport const usedSlots: Record<number, number> = {};\n\n/**\n * This function will take the previous texture batch and the current texture batch and\n * will optimize the current texture batch by reusing already bound textures that are already bound\n *\n * essentially, this should result in lest texture binds in the renderer.\n *\n * and will return the optimized texture batch.\n * @param previousTextureBatch - the previous texture batch to compare to\n * @param currentTextureBatch - the current texture batch modify and optimize\n * @param tick - this batchers tick, used to check if textures were used in the previous batch\n * @param bindingOffset - an offset to the next binding location\n * @returns the optimized texture batch (same as currentTextureBatch)\n */\nexport function optimizeBindings(\n    previousTextureBatch: TextureBatch,\n    currentTextureBatch: TextureBatch,\n    tick: number,\n    bindingOffset: number\n): TextureBatch\n{\n    missingCount = 0;\n    currentCount = 0;\n\n    const boundTextureSize = 16;\n\n    const prev = previousTextureBatch.textures;\n    const next = currentTextureBatch.textures;\n    const curr = currentCopy;\n\n    for (let i = 0; i < next.length; i++)\n    {\n        curr[i] = next[i] as TextureSource;\n        currentCount++;\n    }\n\n    // copy prev to next..\n    for (let i = 0; i < prev.length; i++)\n    {\n        next[i] = prev[i];\n    }\n\n    const batchLocations = currentTextureBatch.batchLocations;\n    // TODO use style source key\n\n    for (let i = 0; i < currentCount; i++)\n    {\n        const boundTexture = curr[i];\n\n        let found = false;\n\n        // find textures that are already bound..\n        for (let j = 0; j < prev.length; j++)\n        {\n            if (boundTexture === prev[j])\n            {\n                found = true;\n                usedSlots[i] = tick;\n                batchLocations[boundTexture.styleSourceKey] = j;\n\n                break;\n            }\n        }\n\n        if (!found)\n        {\n            missing[missingCount++] = curr[i];\n        }\n    }\n\n    for (let i = 0; i < missingCount; i++)\n    {\n        const missingTexture = missing[i];\n\n        for (let j = 0; j < boundTextureSize; j++)\n        {\n            const modJ = (j + bindingOffset) % 16;\n\n            if (usedSlots[modJ] !== tick)\n            {\n                next[modJ] = missingTexture;\n                usedSlots[modJ] = tick;\n\n                batchLocations[missingTexture.styleSourceKey] = modJ;\n\n                break;\n            }\n        }\n    }\n\n    return currentTextureBatch;\n}\n"],"names":["missingCount","currentCount"],"mappings":";;;;AAGO,MAAM,UAA2B,GAAC;AAC9BA,oBAAe,GAAA,EAAA;AAEnB,MAAM,cAA+B,GAAC;AAClCC,oBAAe,GAAA,EAAA;AAEnB,MAAM,YAAoC,GAAC;AAe3C,SAAS,gBACZ,CAAA,oBAAA,EACA,mBACA,EAAA,IAAA,EACA,aAEJ,EAAA;AACI,EAAeD,oBAAA,GAAA,CAAA,CAAA;AACf,EAAeC,oBAAA,GAAA,CAAA,CAAA;AAEf,EAAA,MAAM,gBAAmB,GAAA,EAAA,CAAA;AAEzB,EAAA,MAAM,OAAO,oBAAqB,CAAA,QAAA,CAAA;AAClC,EAAA,MAAM,OAAO,mBAAoB,CAAA,QAAA,CAAA;AACjC,EAAA,MAAM,IAAO,GAAA,WAAA,CAAA;AAEb,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,CAAK,QAAQ,CACjC,EAAA,EAAA;AACI,IAAK,IAAA,CAAA,CAAC,CAAI,GAAA,IAAA,CAAK,CAAC,CAAA,CAAA;AAChB,IAAAA,oBAAA,EAAA,CAAA;AAAA,GACJ;AAGA,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,CAAK,QAAQ,CACjC,EAAA,EAAA;AACI,IAAK,IAAA,CAAA,CAAC,CAAI,GAAA,IAAA,CAAK,CAAC,CAAA,CAAA;AAAA,GACpB;AAEA,EAAA,MAAM,iBAAiB,mBAAoB,CAAA,cAAA,CAAA;AAG3C,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAAA,oBAAA,EAAc,CAClC,EAAA,EAAA;AACI,IAAM,MAAA,YAAA,GAAe,KAAK,CAAC,CAAA,CAAA;AAE3B,IAAA,IAAI,KAAQ,GAAA,KAAA,CAAA;AAGZ,IAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,CAAK,QAAQ,CACjC,EAAA,EAAA;AACI,MAAI,IAAA,YAAA,KAAiB,IAAK,CAAA,CAAC,CAC3B,EAAA;AACI,QAAQ,KAAA,GAAA,IAAA,CAAA;AACR,QAAA,SAAA,CAAU,CAAC,CAAI,GAAA,IAAA,CAAA;AACf,QAAe,cAAA,CAAA,YAAA,CAAa,cAAc,CAAI,GAAA,CAAA,CAAA;AAE9C,QAAA,MAAA;AAAA,OACJ;AAAA,KACJ;AAEA,IAAA,IAAI,CAAC,KACL,EAAA;AACI,MAAQ,OAAA,CAAAD,oBAAA,EAAc,CAAI,GAAA,IAAA,CAAK,CAAC,CAAA,CAAA;AAAA,KACpC;AAAA,GACJ;AAEA,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAAA,oBAAA,EAAc,CAClC,EAAA,EAAA;AACI,IAAM,MAAA,cAAA,GAAiB,QAAQ,CAAC,CAAA,CAAA;AAEhC,IAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,gBAAA,EAAkB,CACtC,EAAA,EAAA;AACI,MAAM,MAAA,IAAA,GAAA,CAAQ,IAAI,aAAiB,IAAA,EAAA,CAAA;AAEnC,MAAI,IAAA,SAAA,CAAU,IAAI,CAAA,KAAM,IACxB,EAAA;AACI,QAAA,IAAA,CAAK,IAAI,CAAI,GAAA,cAAA,CAAA;AACb,QAAA,SAAA,CAAU,IAAI,CAAI,GAAA,IAAA,CAAA;AAElB,QAAe,cAAA,CAAA,cAAA,CAAe,cAAc,CAAI,GAAA,IAAA,CAAA;AAEhD,QAAA,MAAA;AAAA,OACJ;AAAA,KACJ;AAAA,GACJ;AAEA,EAAO,OAAA,mBAAA,CAAA;AACX;;;;;;;"}