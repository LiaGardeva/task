{"version":3,"file":"FilterSystem.mjs","sources":["../../../../src/rendering/filters/shared/FilterSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/Matrix';\nimport { Point } from '../../../maths/Point';\nimport { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../../renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../scene/bounds/Bounds';\nimport { getGlobalBounds } from '../../scene/bounds/getGlobalBounds';\nimport { getGlobalRenderableBounds } from '../../scene/bounds/getRenderableBounds';\n\nimport type { PointData } from '../../../maths/PointData';\nimport type { RenderSurface } from '../../renderers/gpu/renderTarget/GpuRenderTargetSystem';\nimport type { BindResource } from '../../renderers/gpu/shader/BindResource';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { System } from '../../renderers/shared/system/System';\nimport type { Renderer } from '../../renderers/types';\nimport type { Container } from '../../scene/Container';\nimport type { Sprite } from '../../sprite/shared/Sprite';\nimport type { Filter } from '../Filter';\nimport type { FilterEffect } from '../FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            shaderLocation: 0,\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    type: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderTarget,\n}\n\n// eslint-disable-next-line max-len\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    private filterStackIndex = 0;\n    private filterStack: FilterData[] = [];\n\n    private renderer: Renderer;\n\n    private filterGlobalUniforms = new UniformGroup({\n        inputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        inputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        inputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        outputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        backgroundFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        globalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private globalFilterBindGroup: BindGroup = new BindGroup({});\n    private activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this.filterStack[this.filterStackIndex])\n        {\n            this.filterStack[this.filterStackIndex] = this.getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this.filterStack[this.filterStackIndex];\n\n        this.filterStackIndex++;\n\n        const bounds: Bounds = filterData.bounds;\n\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        else\n        {\n            getGlobalBounds(instruction.container, true, bounds);\n        }\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for any filter, it should be true\n        let antialias = renderer.renderTarget.rootRenderTarget.colorTexture.source.antialias;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias !== 'inherit')\n            {\n                if (filter.antialias === 'on')\n                {\n                    antialias = true;\n                }\n                else\n                {\n                    antialias = false;\n                }\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // her we constrain the bounds to the viewport we will render too\n        // need to factor in resolutions also..\n        bounds.scale(resolution)\n            .fit(renderer.renderTarget.rootRenderTarget.viewport)\n            .scale(1 / resolution)\n            .pad(padding)\n            .ceil();\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderTarget;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    pop()\n    {\n        const renderer = this.renderer;\n\n        this.filterStackIndex--;\n        const filterData = this.filterStack[this.filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this.activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n\n            renderer.encoder.finishRenderPass();\n\n            backTexture = this.getBackTexture(filterData.previousRenderSurface, bounds);\n        }\n\n        const offset = Point.shared;\n\n        // get previous bounds..\n        if (this.filterStackIndex > 0)\n        {\n            offset.x = this.filterStack[this.filterStackIndex - 1].bounds.minX;\n            offset.y = this.filterStack[this.filterStackIndex - 1].bounds.minY;\n        }\n\n        // update all the global uniforms used by each filter\n        this.updateGlobalFilterUniforms(bounds, inputTexture, backTexture, offset);\n\n        const filters = filterData.filterEffect.filters;\n\n        this.filterGlobalUniforms.update();\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // eslint-disable-next-line max-len\n\n        let globalUniforms: BindResource = this.filterGlobalUniforms;\n\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            globalUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUniformBufferResource(this.filterGlobalUniforms);\n        }\n\n        // update the resources on the bind group...\n        this.globalFilterBindGroup.setResource(globalUniforms, 0);\n        this.globalFilterBindGroup.setResource(inputTexture.style, 2);\n        this.globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        if (filters.length === 1)\n        {\n            renderer.globalUniforms.pop();\n\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // logDebugTexture(inputTexture, this.renderer);\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            const outputFrame = this.filterGlobalUniforms.uniforms.outputFrame;\n\n            // when rendering to another texture we need to reset the offset of the filter outPutFrame\n            // basically we want it tucked into the top left corner..\n            // we can then set the offset back again when its rendered to the final target\n            const oX = outputFrame[0];\n            const oY = outputFrame[1];\n\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n            this.filterGlobalUniforms.update();\n\n            if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n            {\n                const globalUniforms2 = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                    .getUniformBufferResource(this.filterGlobalUniforms);\n\n                this.globalFilterBindGroup.setResource(globalUniforms2, 0);\n            }\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            // remove the global uniforms we added\n\n            renderer.globalUniforms.pop();\n\n            if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n            {\n                this.globalFilterBindGroup.setResource(globalUniforms, 0);\n            }\n            else\n            {\n                outputFrame[0] = oX;\n                outputFrame[1] = oY;\n                this.filterGlobalUniforms.update();\n            }\n\n            // BUG - global frame is only correct for the last filter in the stack\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    updateGlobalFilterUniforms(bounds: Bounds, texture: Texture, backTexture: Texture, offset: PointData)\n    {\n        const bx = bounds.minX;\n        const by = bounds.minY;\n\n        const uniforms = this.filterGlobalUniforms.uniforms;\n\n        const outputFrame = uniforms.outputFrame;\n        const inputSize = uniforms.inputSize;\n        const inputPixel = uniforms.inputPixel;\n        const inputClamp = uniforms.inputClamp;\n        const backgroundFrame = uniforms.backgroundFrame;\n        const globalFrame = uniforms.globalFrame;\n\n        outputFrame[0] = bx - offset.x;\n        outputFrame[1] = by - offset.y;\n        outputFrame[2] = texture.frameWidth;\n        outputFrame[3] = texture.frameHeight;\n\n        inputSize[0] = texture.source.width;\n        inputSize[1] = texture.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = texture.source.pixelWidth;\n        inputPixel[1] = texture.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (texture.frameWidth * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (texture.frameHeight * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        backgroundFrame[0] = 0;\n        backgroundFrame[1] = 0;\n        backgroundFrame[2] = backTexture.layout.frame.width;\n        backgroundFrame[3] = backTexture.layout.frame.height;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        if (this.filterStackIndex > 0)\n        {\n            resolution = this.filterStack[this.filterStackIndex - 1].inputTexture.source._resolution;\n        }\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n    }\n\n    getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (this.filterStackIndex)\n        {\n            x -= this.filterStack[this.filterStackIndex - 1].bounds.minX;\n            y -= this.filterStack[this.filterStackIndex - 1].bounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height }\n        );\n\n        return backTexture;\n    }\n\n    applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        // set bind group..\n        this.globalFilterBindGroup.setResource(input.source, 1);\n\n        filter.groups[0] = renderer.globalUniforms.bindGroup;\n        filter.groups[1] = this.globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n    }\n\n    getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {PIXI.Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this.activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(1.0 / (sprite.texture.frameWidth), 1.0 / (sprite.texture.frameHeight));\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    destroy()\n    {\n        // BOOM!\n    }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;AA6BA,MAAM,YAAA,GAAe,IAAI,QAAS,CAAA;AAAA,EAC9B,UAAY,EAAA;AAAA,IACR,SAAW,EAAA;AAAA,MACP,MAAQ,EAAA,IAAI,YAAa,CAAA,CAAC,CAAG,EAAA,CAAA,EAAG,CAAG,EAAA,CAAA,EAAG,CAAG,EAAA,CAAA,EAAG,CAAG,EAAA,CAAC,CAAC,CAAA;AAAA,MACjD,cAAgB,EAAA,CAAA;AAAA,MAChB,MAAQ,EAAA,WAAA;AAAA,MACR,QAAQ,CAAI,GAAA,CAAA;AAAA,MACZ,MAAQ,EAAA,CAAA;AAAA,KACZ;AAAA,GACJ;AAAA,EACA,WAAA,EAAa,IAAI,WAAA,CAAY,CAAC,CAAA,EAAG,GAAG,CAAG,EAAA,CAAA,EAAG,CAAG,EAAA,CAAC,CAAC,CAAA;AACnD,CAAC,CAAA,CAAA;AA4CM,MAAM,YACb,CAAA;AAAA,EA2BI,YAAY,QACZ,EAAA;AAlBA,IAAA,IAAA,CAAQ,gBAAmB,GAAA,CAAA,CAAA;AAC3B,IAAA,IAAA,CAAQ,cAA4B,EAAC,CAAA;AAIrC,IAAQ,IAAA,CAAA,oBAAA,GAAuB,IAAI,YAAa,CAAA;AAAA,MAC5C,SAAA,EAAW,EAAE,KAAO,EAAA,IAAI,aAAa,CAAC,CAAA,EAAG,MAAM,WAAY,EAAA;AAAA,MAC3D,UAAA,EAAY,EAAE,KAAO,EAAA,IAAI,aAAa,CAAC,CAAA,EAAG,MAAM,WAAY,EAAA;AAAA,MAC5D,UAAA,EAAY,EAAE,KAAO,EAAA,IAAI,aAAa,CAAC,CAAA,EAAG,MAAM,WAAY,EAAA;AAAA,MAC5D,WAAA,EAAa,EAAE,KAAO,EAAA,IAAI,aAAa,CAAC,CAAA,EAAG,MAAM,WAAY,EAAA;AAAA,MAC7D,eAAA,EAAiB,EAAE,KAAO,EAAA,IAAI,aAAa,CAAC,CAAA,EAAG,MAAM,WAAY,EAAA;AAAA,MACjE,WAAA,EAAa,EAAE,KAAO,EAAA,IAAI,aAAa,CAAC,CAAA,EAAG,MAAM,WAAY,EAAA;AAAA,KAChE,CAAA,CAAA;AAED,IAAA,IAAA,CAAQ,qBAAmC,GAAA,IAAI,SAAU,CAAA,EAAE,CAAA,CAAA;AAKvD,IAAA,IAAA,CAAK,QAAW,GAAA,QAAA,CAAA;AAAA,GACpB;AAAA,EAEA,KAAK,WACL,EAAA;AACI,IAAA,MAAM,WAAW,IAAK,CAAA,QAAA,CAAA;AAEtB,IAAM,MAAA,OAAA,GAAU,YAAY,YAAa,CAAA,OAAA,CAAA;AAEzC,IAAA,IAAI,CAAC,IAAA,CAAK,WAAY,CAAA,IAAA,CAAK,gBAAgB,CAC3C,EAAA;AACI,MAAA,IAAA,CAAK,WAAY,CAAA,IAAA,CAAK,gBAAgB,CAAA,GAAI,KAAK,aAAc,EAAA,CAAA;AAAA,KACjE;AAIA,IAAA,MAAM,UAAa,GAAA,IAAA,CAAK,WAAY,CAAA,IAAA,CAAK,gBAAgB,CAAA,CAAA;AAEzD,IAAK,IAAA,CAAA,gBAAA,EAAA,CAAA;AAEL,IAAA,MAAM,SAAiB,UAAW,CAAA,MAAA,CAAA;AAElC,IAAA,IAAI,YAAY,WAChB,EAAA;AACI,MAA0B,yBAAA,CAAA,WAAA,CAAY,aAAa,MAAM,CAAA,CAAA;AAAA,KAG7D,MAAA;AACI,MAAgB,eAAA,CAAA,WAAA,CAAY,SAAW,EAAA,IAAA,EAAM,MAAM,CAAA,CAAA;AAAA,KACvD;AAIA,IAAI,IAAA,OAAA,CAAQ,WAAW,CACvB,EAAA;AACI,MAAA,UAAA,CAAW,IAAO,GAAA,IAAA,CAAA;AAElB,MAAA,OAAA;AAAA,KACJ;AAIA,IAAA,IAAI,UAAa,GAAA,QAAA,CAAS,YAAa,CAAA,gBAAA,CAAiB,aAAa,MAAO,CAAA,WAAA,CAAA;AAG5E,IAAA,IAAI,OAAU,GAAA,CAAA,CAAA;AAEd,IAAA,IAAI,SAAY,GAAA,QAAA,CAAS,YAAa,CAAA,gBAAA,CAAiB,aAAa,MAAO,CAAA,SAAA,CAAA;AAE3E,IAAA,IAAI,aAAgB,GAAA,KAAA,CAAA;AAEpB,IAAA,IAAI,OAAU,GAAA,KAAA,CAAA;AAEd,IAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,OAAA,CAAQ,QAAQ,CACpC,EAAA,EAAA;AACI,MAAM,MAAA,MAAA,GAAS,QAAQ,CAAC,CAAA,CAAA;AAExB,MAAA,UAAA,GAAa,IAAK,CAAA,GAAA,CAAI,UAAY,EAAA,MAAA,CAAO,UAAU,CAAA,CAAA;AACnD,MAAA,OAAA,IAAW,MAAO,CAAA,OAAA,CAAA;AAElB,MAAI,IAAA,MAAA,CAAO,cAAc,SACzB,EAAA;AACI,QAAI,IAAA,MAAA,CAAO,cAAc,IACzB,EAAA;AACI,UAAY,SAAA,GAAA,IAAA,CAAA;AAAA,SAGhB,MAAA;AACI,UAAY,SAAA,GAAA,KAAA,CAAA;AAAA,SAChB;AAAA,OACJ;AAEA,MAAA,OAAA,GAAU,OAAO,OAAW,IAAA,OAAA,CAAA;AAC5B,MAAA,aAAA,GAAgB,iBAAiB,MAAO,CAAA,aAAA,CAAA;AAAA,KAC5C;AAGA,IAAA,IAAI,CAAC,OACL,EAAA;AACI,MAAA,UAAA,CAAW,IAAO,GAAA,IAAA,CAAA;AAElB,MAAA,OAAA;AAAA,KACJ;AAIA,IAAA,MAAA,CAAO,MAAM,UAAU,CAAA,CAClB,GAAI,CAAA,QAAA,CAAS,aAAa,gBAAiB,CAAA,QAAQ,CACnD,CAAA,KAAA,CAAM,IAAI,UAAU,CAAA,CACpB,GAAI,CAAA,OAAO,EACX,IAAK,EAAA,CAAA;AAIV,IAAI,IAAA,CAAC,OAAO,UACZ,EAAA;AACI,MAAA,UAAA,CAAW,IAAO,GAAA,IAAA,CAAA;AAElB,MAAA,OAAA;AAAA,KACJ;AAGA,IAAA,UAAA,CAAW,IAAO,GAAA,KAAA,CAAA;AAElB,IAAA,UAAA,CAAW,MAAS,GAAA,MAAA,CAAA;AACpB,IAAA,UAAA,CAAW,aAAgB,GAAA,aAAA,CAAA;AAC3B,IAAA,UAAA,CAAW,YAAY,WAAY,CAAA,SAAA,CAAA;AACnC,IAAA,UAAA,CAAW,eAAe,WAAY,CAAA,YAAA,CAAA;AAEtC,IAAW,UAAA,CAAA,qBAAA,GAAwB,SAAS,YAAa,CAAA,YAAA,CAAA;AAIzD,IAAA,UAAA,CAAW,eAAe,WAAY,CAAA,iBAAA;AAAA,MAClC,MAAO,CAAA,KAAA;AAAA,MACP,MAAO,CAAA,MAAA;AAAA,MACP,UAAA;AAAA,MACA,SAAA;AAAA,KACJ,CAAA;AAEA,IAAA,QAAA,CAAS,YAAa,CAAA,IAAA,CAAK,UAAW,CAAA,YAAA,EAAc,IAAI,CAAA,CAAA;AAGxD,IAAA,QAAA,CAAS,eAAe,IAAK,CAAA;AAAA,MACzB,MAAQ,EAAA,MAAA;AAAA,KACX,CAAA,CAAA;AAAA,GACL;AAAA,EAEA,GACA,GAAA;AACI,IAAA,MAAM,WAAW,IAAK,CAAA,QAAA,CAAA;AAEtB,IAAK,IAAA,CAAA,gBAAA,EAAA,CAAA;AACL,IAAA,MAAM,UAAa,GAAA,IAAA,CAAK,WAAY,CAAA,IAAA,CAAK,gBAAgB,CAAA,CAAA;AAGzD,IAAA,IAAI,WAAW,IACf,EAAA;AACI,MAAA,OAAA;AAAA,KACJ;AAEA,IAAA,IAAA,CAAK,gBAAmB,GAAA,UAAA,CAAA;AAExB,IAAA,MAAM,eAAe,UAAW,CAAA,YAAA,CAAA;AAEhC,IAAA,MAAM,SAAS,UAAW,CAAA,MAAA,CAAA;AAE1B,IAAA,IAAI,cAAc,OAAQ,CAAA,KAAA,CAAA;AAE1B,IAAA,IAAI,WAAW,aACf,EAAA;AAII,MAAA,QAAA,CAAS,QAAQ,gBAAiB,EAAA,CAAA;AAElC,MAAA,WAAA,GAAc,IAAK,CAAA,cAAA,CAAe,UAAW,CAAA,qBAAA,EAAuB,MAAM,CAAA,CAAA;AAAA,KAC9E;AAEA,IAAA,MAAM,SAAS,KAAM,CAAA,MAAA,CAAA;AAGrB,IAAI,IAAA,IAAA,CAAK,mBAAmB,CAC5B,EAAA;AACI,MAAA,MAAA,CAAO,IAAI,IAAK,CAAA,WAAA,CAAY,KAAK,gBAAmB,GAAA,CAAC,EAAE,MAAO,CAAA,IAAA,CAAA;AAC9D,MAAA,MAAA,CAAO,IAAI,IAAK,CAAA,WAAA,CAAY,KAAK,gBAAmB,GAAA,CAAC,EAAE,MAAO,CAAA,IAAA,CAAA;AAAA,KAClE;AAGA,IAAA,IAAA,CAAK,0BAA2B,CAAA,MAAA,EAAQ,YAAc,EAAA,WAAA,EAAa,MAAM,CAAA,CAAA;AAEzE,IAAM,MAAA,OAAA,GAAU,WAAW,YAAa,CAAA,OAAA,CAAA;AAExC,IAAA,IAAA,CAAK,qBAAqB,MAAO,EAAA,CAAA;AAOjC,IAAA,IAAI,iBAA+B,IAAK,CAAA,oBAAA,CAAA;AAExC,IAAK,IAAA,QAAA,CAA4B,YAAY,YAC7C,EAAA;AACI,MAAA,cAAA,GAAkB,QAA4B,CAAA,WAAA,CAAY,YACrD,CAAA,wBAAA,CAAyB,KAAK,oBAAoB,CAAA,CAAA;AAAA,KAC3D;AAGA,IAAK,IAAA,CAAA,qBAAA,CAAsB,WAAY,CAAA,cAAA,EAAgB,CAAC,CAAA,CAAA;AACxD,IAAA,IAAA,CAAK,qBAAsB,CAAA,WAAA,CAAY,YAAa,CAAA,KAAA,EAAO,CAAC,CAAA,CAAA;AAC5D,IAAA,IAAA,CAAK,qBAAsB,CAAA,WAAA,CAAY,WAAY,CAAA,MAAA,EAAQ,CAAC,CAAA,CAAA;AAE5D,IAAI,IAAA,OAAA,CAAQ,WAAW,CACvB,EAAA;AACI,MAAA,QAAA,CAAS,eAAe,GAAI,EAAA,CAAA;AAI5B,MAAA,OAAA,CAAQ,CAAC,CAAE,CAAA,KAAA,CAAM,MAAM,YAAc,EAAA,UAAA,CAAW,uBAAuB,KAAK,CAAA,CAAA;AAI5E,MAAA,WAAA,CAAY,cAAc,YAAY,CAAA,CAAA;AAAA,KAG1C,MAAA;AACI,MAAA,IAAI,OAAO,UAAW,CAAA,YAAA,CAAA;AAEtB,MAAM,MAAA,WAAA,GAAc,IAAK,CAAA,oBAAA,CAAqB,QAAS,CAAA,WAAA,CAAA;AAKvD,MAAM,MAAA,EAAA,GAAK,YAAY,CAAC,CAAA,CAAA;AACxB,MAAM,MAAA,EAAA,GAAK,YAAY,CAAC,CAAA,CAAA;AAExB,MAAA,WAAA,CAAY,CAAC,CAAI,GAAA,CAAA,CAAA;AACjB,MAAA,WAAA,CAAY,CAAC,CAAI,GAAA,CAAA,CAAA;AACjB,MAAA,IAAA,CAAK,qBAAqB,MAAO,EAAA,CAAA;AAEjC,MAAK,IAAA,QAAA,CAA4B,YAAY,YAC7C,EAAA;AACI,QAAA,MAAM,kBAAmB,QAA4B,CAAA,WAAA,CAAY,YAC5D,CAAA,wBAAA,CAAyB,KAAK,oBAAoB,CAAA,CAAA;AAEvD,QAAK,IAAA,CAAA,qBAAA,CAAsB,WAAY,CAAA,eAAA,EAAiB,CAAC,CAAA,CAAA;AAAA,OAC7D;AAGA,MAAA,IAAI,OAAO,WAAY,CAAA,iBAAA;AAAA,QACnB,MAAO,CAAA,KAAA;AAAA,QACP,MAAO,CAAA,MAAA;AAAA,QACP,KAAK,MAAO,CAAA,WAAA;AAAA,QACZ,KAAA;AAAA,OACJ,CAAA;AAEA,MAAA,IAAI,CAAI,GAAA,CAAA,CAAA;AAGR,MAAA,KAAK,IAAI,CAAG,EAAA,CAAA,GAAI,QAAQ,MAAS,GAAA,CAAA,EAAG,EAAE,CACtC,EAAA;AACI,QAAM,MAAA,MAAA,GAAS,QAAQ,CAAC,CAAA,CAAA;AAExB,QAAA,MAAA,CAAO,KAAM,CAAA,IAAA,EAAM,IAAM,EAAA,IAAA,EAAM,IAAI,CAAA,CAAA;AACnC,QAAA,MAAM,CAAI,GAAA,IAAA,CAAA;AAEV,QAAO,IAAA,GAAA,IAAA,CAAA;AACP,QAAO,IAAA,GAAA,CAAA,CAAA;AAAA,OACX;AAIA,MAAA,QAAA,CAAS,eAAe,GAAI,EAAA,CAAA;AAE5B,MAAK,IAAA,QAAA,CAA4B,YAAY,YAC7C,EAAA;AACI,QAAK,IAAA,CAAA,qBAAA,CAAsB,WAAY,CAAA,cAAA,EAAgB,CAAC,CAAA,CAAA;AAAA,OAG5D,MAAA;AACI,QAAA,WAAA,CAAY,CAAC,CAAI,GAAA,EAAA,CAAA;AACjB,QAAA,WAAA,CAAY,CAAC,CAAI,GAAA,EAAA,CAAA;AACjB,QAAA,IAAA,CAAK,qBAAqB,MAAO,EAAA,CAAA;AAAA,OACrC;AAGA,MAAA,OAAA,CAAQ,CAAC,CAAE,CAAA,KAAA,CAAM,MAAM,IAAM,EAAA,UAAA,CAAW,uBAAuB,KAAK,CAAA,CAAA;AAGpE,MAAA,WAAA,CAAY,cAAc,IAAI,CAAA,CAAA;AAC9B,MAAA,WAAA,CAAY,cAAc,IAAI,CAAA,CAAA;AAAA,KAClC;AAGA,IAAA,IAAI,WAAW,aACf,EAAA;AACI,MAAA,WAAA,CAAY,cAAc,WAAW,CAAA,CAAA;AAAA,KACzC;AAAA,GACJ;AAAA,EAEA,0BAA2B,CAAA,MAAA,EAAgB,OAAkB,EAAA,WAAA,EAAsB,MACnF,EAAA;AACI,IAAA,MAAM,KAAK,MAAO,CAAA,IAAA,CAAA;AAClB,IAAA,MAAM,KAAK,MAAO,CAAA,IAAA,CAAA;AAElB,IAAM,MAAA,QAAA,GAAW,KAAK,oBAAqB,CAAA,QAAA,CAAA;AAE3C,IAAA,MAAM,cAAc,QAAS,CAAA,WAAA,CAAA;AAC7B,IAAA,MAAM,YAAY,QAAS,CAAA,SAAA,CAAA;AAC3B,IAAA,MAAM,aAAa,QAAS,CAAA,UAAA,CAAA;AAC5B,IAAA,MAAM,aAAa,QAAS,CAAA,UAAA,CAAA;AAC5B,IAAA,MAAM,kBAAkB,QAAS,CAAA,eAAA,CAAA;AACjC,IAAA,MAAM,cAAc,QAAS,CAAA,WAAA,CAAA;AAE7B,IAAY,WAAA,CAAA,CAAC,CAAI,GAAA,EAAA,GAAK,MAAO,CAAA,CAAA,CAAA;AAC7B,IAAY,WAAA,CAAA,CAAC,CAAI,GAAA,EAAA,GAAK,MAAO,CAAA,CAAA,CAAA;AAC7B,IAAY,WAAA,CAAA,CAAC,IAAI,OAAQ,CAAA,UAAA,CAAA;AACzB,IAAY,WAAA,CAAA,CAAC,IAAI,OAAQ,CAAA,WAAA,CAAA;AAEzB,IAAU,SAAA,CAAA,CAAC,CAAI,GAAA,OAAA,CAAQ,MAAO,CAAA,KAAA,CAAA;AAC9B,IAAU,SAAA,CAAA,CAAC,CAAI,GAAA,OAAA,CAAQ,MAAO,CAAA,MAAA,CAAA;AAC9B,IAAA,SAAA,CAAU,CAAC,CAAA,GAAI,CAAI,GAAA,SAAA,CAAU,CAAC,CAAA,CAAA;AAC9B,IAAA,SAAA,CAAU,CAAC,CAAA,GAAI,CAAI,GAAA,SAAA,CAAU,CAAC,CAAA,CAAA;AAE9B,IAAW,UAAA,CAAA,CAAC,CAAI,GAAA,OAAA,CAAQ,MAAO,CAAA,UAAA,CAAA;AAC/B,IAAW,UAAA,CAAA,CAAC,CAAI,GAAA,OAAA,CAAQ,MAAO,CAAA,WAAA,CAAA;AAC/B,IAAA,UAAA,CAAW,CAAC,CAAA,GAAI,CAAM,GAAA,UAAA,CAAW,CAAC,CAAA,CAAA;AAClC,IAAA,UAAA,CAAW,CAAC,CAAA,GAAI,CAAM,GAAA,UAAA,CAAW,CAAC,CAAA,CAAA;AAElC,IAAA,UAAA,CAAW,CAAC,CAAA,GAAI,GAAM,GAAA,UAAA,CAAW,CAAC,CAAA,CAAA;AAClC,IAAA,UAAA,CAAW,CAAC,CAAA,GAAI,GAAM,GAAA,UAAA,CAAW,CAAC,CAAA,CAAA;AAClC,IAAW,UAAA,CAAA,CAAC,IAAK,OAAQ,CAAA,UAAA,GAAa,UAAU,CAAC,CAAA,GAAM,GAAM,GAAA,UAAA,CAAW,CAAC,CAAA,CAAA;AACzE,IAAW,UAAA,CAAA,CAAC,IAAK,OAAQ,CAAA,WAAA,GAAc,UAAU,CAAC,CAAA,GAAM,GAAM,GAAA,UAAA,CAAW,CAAC,CAAA,CAAA;AAE1E,IAAA,eAAA,CAAgB,CAAC,CAAI,GAAA,CAAA,CAAA;AACrB,IAAA,eAAA,CAAgB,CAAC,CAAI,GAAA,CAAA,CAAA;AACrB,IAAA,eAAA,CAAgB,CAAC,CAAA,GAAI,WAAY,CAAA,MAAA,CAAO,KAAM,CAAA,KAAA,CAAA;AAC9C,IAAA,eAAA,CAAgB,CAAC,CAAA,GAAI,WAAY,CAAA,MAAA,CAAO,KAAM,CAAA,MAAA,CAAA;AAE9C,IAAA,IAAI,aAAa,IAAK,CAAA,QAAA,CAAS,YAAa,CAAA,gBAAA,CAAiB,aAAa,MAAO,CAAA,WAAA,CAAA;AAEjF,IAAI,IAAA,IAAA,CAAK,mBAAmB,CAC5B,EAAA;AACI,MAAA,UAAA,GAAa,KAAK,WAAY,CAAA,IAAA,CAAK,mBAAmB,CAAC,CAAA,CAAE,aAAa,MAAO,CAAA,WAAA,CAAA;AAAA,KACjF;AAEA,IAAY,WAAA,CAAA,CAAC,CAAI,GAAA,MAAA,CAAO,CAAI,GAAA,UAAA,CAAA;AAC5B,IAAY,WAAA,CAAA,CAAC,CAAI,GAAA,MAAA,CAAO,CAAI,GAAA,UAAA,CAAA;AAE5B,IAAA,MAAM,WAAc,GAAA,IAAA,CAAK,QAAS,CAAA,YAAA,CAAa,gBAAiB,CAAA,YAAA,CAAA;AAEhE,IAAA,WAAA,CAAY,CAAC,CAAA,GAAI,WAAY,CAAA,MAAA,CAAO,KAAQ,GAAA,UAAA,CAAA;AAC5C,IAAA,WAAA,CAAY,CAAC,CAAA,GAAI,WAAY,CAAA,MAAA,CAAO,MAAS,GAAA,UAAA,CAAA;AAAA,GACjD;AAAA,EAEA,cAAA,CAAe,mBAAiC,MAChD,EAAA;AACI,IAAM,MAAA,oBAAA,GAAuB,iBAAkB,CAAA,YAAA,CAAa,MAAO,CAAA,WAAA,CAAA;AAEnE,IAAA,MAAM,cAAc,WAAY,CAAA,iBAAA;AAAA,MAC5B,MAAO,CAAA,KAAA;AAAA,MACP,MAAO,CAAA,MAAA;AAAA,MACP,oBAAA;AAAA,MACA,KAAA;AAAA,KACJ,CAAA;AAEA,IAAA,IAAI,IAAI,MAAO,CAAA,IAAA,CAAA;AACf,IAAA,IAAI,IAAI,MAAO,CAAA,IAAA,CAAA;AAEf,IAAA,IAAI,KAAK,gBACT,EAAA;AACI,MAAA,CAAA,IAAK,KAAK,WAAY,CAAA,IAAA,CAAK,gBAAmB,GAAA,CAAC,EAAE,MAAO,CAAA,IAAA,CAAA;AACxD,MAAA,CAAA,IAAK,KAAK,WAAY,CAAA,IAAA,CAAK,gBAAmB,GAAA,CAAC,EAAE,MAAO,CAAA,IAAA,CAAA;AAAA,KAC5D;AAEA,IAAI,CAAA,GAAA,IAAA,CAAK,KAAM,CAAA,CAAA,GAAI,oBAAoB,CAAA,CAAA;AACvC,IAAI,CAAA,GAAA,IAAA,CAAK,KAAM,CAAA,CAAA,GAAI,oBAAoB,CAAA,CAAA;AAEvC,IAAA,MAAM,KAAQ,GAAA,IAAA,CAAK,IAAK,CAAA,MAAA,CAAO,QAAQ,oBAAoB,CAAA,CAAA;AAC3D,IAAA,MAAM,MAAS,GAAA,IAAA,CAAK,IAAK,CAAA,MAAA,CAAO,SAAS,oBAAoB,CAAA,CAAA;AAE7D,IAAA,IAAA,CAAK,SAAS,YAAa,CAAA,aAAA;AAAA,MACvB,iBAAA;AAAA,MACA,WAAA;AAAA,MACA,EAAE,GAAG,CAAE,EAAA;AAAA,MACP,EAAE,OAAO,MAAO,EAAA;AAAA,KACpB,CAAA;AAEA,IAAO,OAAA,WAAA,CAAA;AAAA,GACX;AAAA,EAEA,WAAY,CAAA,MAAA,EAAgB,KAAgB,EAAA,MAAA,EAAuB,KACnE,EAAA;AACI,IAAA,MAAM,WAAW,IAAK,CAAA,QAAA,CAAA;AAEtB,IAAA,QAAA,CAAS,YAAa,CAAA,IAAA,CAAK,MAAQ,EAAA,CAAC,CAAC,KAAK,CAAA,CAAA;AAG1C,IAAA,IAAA,CAAK,qBAAsB,CAAA,WAAA,CAAY,KAAM,CAAA,MAAA,EAAQ,CAAC,CAAA,CAAA;AAEtD,IAAA,MAAA,CAAO,MAAO,CAAA,CAAC,CAAI,GAAA,QAAA,CAAS,cAAe,CAAA,SAAA,CAAA;AAC3C,IAAO,MAAA,CAAA,MAAA,CAAO,CAAC,CAAA,GAAI,IAAK,CAAA,qBAAA,CAAA;AAExB,IAAA,QAAA,CAAS,QAAQ,IAAK,CAAA;AAAA,MAClB,QAAU,EAAA,YAAA;AAAA,MACV,MAAQ,EAAA,MAAA;AAAA,MACR,OAAO,MAAO,CAAA,MAAA;AAAA,MACd,QAAU,EAAA,eAAA;AAAA,KACb,CAAA,CAAA;AAAA,GACL;AAAA,EAEA,aACA,GAAA;AACI,IAAO,OAAA;AAAA,MACH,IAAM,EAAA,KAAA;AAAA,MACN,YAAc,EAAA,IAAA;AAAA,MACd,MAAA,EAAQ,IAAI,MAAO,EAAA;AAAA,MACnB,SAAW,EAAA,IAAA;AAAA,MACX,YAAc,EAAA,IAAA;AAAA,MACd,aAAe,EAAA,KAAA;AAAA,MACf,qBAAuB,EAAA,IAAA;AAAA,KAC3B,CAAA;AAAA,GACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,qBAAA,CAAsB,cAAsB,MAC5C,EAAA;AACI,IAAA,MAAM,OAAO,IAAK,CAAA,gBAAA,CAAA;AAElB,IAAA,MAAM,eAAe,YAAa,CAAA,GAAA;AAAA,MAC9B,IAAA,CAAK,aAAa,OAAQ,CAAA,KAAA;AAAA,MAC1B,CAAA;AAAA,MAAG,CAAA;AAAA,MACH,IAAA,CAAK,aAAa,OAAQ,CAAA,MAAA;AAAA,MAC1B,KAAK,MAAO,CAAA,IAAA;AAAA,MAAM,KAAK,MAAO,CAAA,IAAA;AAAA,KAClC,CAAA;AAEA,IAAA,MAAM,cAAiB,GAAA,MAAA,CAAO,cAAe,CAAA,MAAA,CAAO,OAAO,MAAM,CAAA,CAAA;AAEjE,IAAA,cAAA,CAAe,MAAO,EAAA,CAAA;AACtB,IAAA,YAAA,CAAa,QAAQ,cAAc,CAAA,CAAA;AACnC,IAAa,YAAA,CAAA,KAAA,CAAM,IAAO,MAAO,CAAA,OAAA,CAAQ,YAAa,CAAO,GAAA,MAAA,CAAO,QAAQ,WAAY,CAAA,CAAA;AAExF,IAAA,YAAA,CAAa,UAAU,MAAO,CAAA,MAAA,CAAO,CAAG,EAAA,MAAA,CAAO,OAAO,CAAC,CAAA,CAAA;AAEvD,IAAO,OAAA,YAAA,CAAA;AAAA,GACX;AAAA,EAEA,OACA,GAAA;AAAA,GAEA;AACJ,CAAA;AAAA;AArda,YAAA,CAGF,SAAY,GAAA;AAAA,EACf,IAAM,EAAA;AAAA,IACF,aAAc,CAAA,WAAA;AAAA,IACd,aAAc,CAAA,YAAA;AAAA,GAClB;AAAA,EACA,IAAM,EAAA,QAAA;AACV,CAAA;;;;"}