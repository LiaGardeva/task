{"version":3,"file":"GpuScissorMaskPipe.js","sources":["../../../../src/rendering/mask/gpu/GpuScissorMaskPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Bounds } from '../../scene/bounds/Bounds';\nimport { getGlobalBounds } from '../../scene/bounds/getGlobalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Container } from '../../scene/Container';\nimport type { ScissorMask } from '../shared/ScissorMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nexport interface ScissorMaskInstruction extends Instruction\n{\n    type: 'scissorMask',\n    action: MaskMode,\n    mask: ScissorMask\n}\n\nconst tempBounds = new Bounds();\n\nexport class GpuScissorMaskPipe implements InstructionPipe<ScissorMaskInstruction>\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'scissorMask',\n    };\n\n    private renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this.renderer = renderer;\n    }\n\n    push(mask: ScissorMask, _container: Container, instructionSet: InstructionSet): void\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            type: 'scissorMask',\n            action: 'pushMaskBegin',\n            mask,\n            canBundle: false,\n        } as ScissorMaskInstruction);\n    }\n\n    pop(_mask: ScissorMask, _container: Container, instructionSet: InstructionSet): void\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            type: 'scissorMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    execute(instruction: ScissorMaskInstruction)\n    {\n        const renderer = this.renderer;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n            bounds.ceil();\n\n            renderer.encoder.setScissor(bounds);\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.encoder.clearScissor();\n        }\n    }\n}\n"],"names":["Bounds","getGlobalBounds","ExtensionType"],"mappings":";;;;;;;;AAqBA,MAAM,UAAA,GAAa,IAAIA,aAAO,EAAA,CAAA;AAEvB,MAAM,kBACb,CAAA;AAAA,EAWI,YAAY,QACZ,EAAA;AACI,IAAA,IAAA,CAAK,QAAW,GAAA,QAAA,CAAA;AAAA,GACpB;AAAA,EAEA,IAAA,CAAK,IAAmB,EAAA,UAAA,EAAuB,cAC/C,EAAA;AACI,IAAA,IAAA,CAAK,QAAS,CAAA,WAAA,CAAY,KAAM,CAAA,KAAA,CAAM,cAAc,CAAA,CAAA;AAEpD,IAAA,cAAA,CAAe,GAAI,CAAA;AAAA,MACf,IAAM,EAAA,aAAA;AAAA,MACN,MAAQ,EAAA,eAAA;AAAA,MACR,IAAA;AAAA,MACA,SAAW,EAAA,KAAA;AAAA,KACY,CAAA,CAAA;AAAA,GAC/B;AAAA,EAEA,GAAA,CAAI,KAAoB,EAAA,UAAA,EAAuB,cAC/C,EAAA;AACI,IAAA,IAAA,CAAK,QAAS,CAAA,WAAA,CAAY,KAAM,CAAA,KAAA,CAAM,cAAc,CAAA,CAAA;AAEpD,IAAA,cAAA,CAAe,GAAI,CAAA;AAAA,MACf,IAAM,EAAA,aAAA;AAAA,MACN,MAAQ,EAAA,YAAA;AAAA,MACR,SAAW,EAAA,KAAA;AAAA,KACd,CAAA,CAAA;AAAA,GACL;AAAA,EAEA,QAAQ,WACR,EAAA;AACI,IAAA,MAAM,WAAW,IAAK,CAAA,QAAA,CAAA;AAEtB,IAAI,IAAA,WAAA,CAAY,WAAW,eAC3B,EAAA;AACI,MAAA,MAAM,SAASC,+BAAgB,CAAA,WAAA,CAAY,IAAK,CAAA,IAAA,EAAM,MAAM,UAAU,CAAA,CAAA;AAEtE,MAAA,MAAA,CAAO,IAAK,EAAA,CAAA;AAEZ,MAAS,QAAA,CAAA,OAAA,CAAQ,WAAW,MAAM,CAAA,CAAA;AAAA,KACtC,MAAA,IACS,WAAY,CAAA,MAAA,KAAW,YAChC,EAAA;AACI,MAAA,QAAA,CAAS,QAAQ,YAAa,EAAA,CAAA;AAAA,KAClC;AAAA,GACJ;AACJ,CAAA;AAAA;AAzDa,kBAAA,CAGF,SAA+B,GAAA;AAAA,EAClC,IAAM,EAAA;AAAA,IACFC,wBAAc,CAAA,WAAA;AAAA,GAClB;AAAA,EACA,IAAM,EAAA,aAAA;AACV,CAAA;;;;"}