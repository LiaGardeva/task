{"version":3,"file":"AlphaMask.mjs","sources":["../../../../src/rendering/mask/shared/AlphaMask.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Sprite } from '../../sprite/shared/Sprite';\nimport { addMaskBounds } from './addMaskBounds';\nimport { addMaskLocalBounds } from './addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { PointData } from '../../../maths/PointData';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Bounds } from '../../scene/bounds/Bounds';\nimport type { Container } from '../../scene/Container';\nimport type { Effect } from '../../scene/Effect';\n\nexport class AlphaMask implements Effect, PoolItem\n{\n    static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    priority = 0;\n    mask: Container;\n    pipe = 'alphaMask';\n    renderMaskToTexture: boolean;\n\n    constructor(options?: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    init(mask: Container): void\n    {\n        this.mask = mask;\n\n        // TODO - might want to change this to adjust on the fly\n        // user may add children to the sprite..\n        this.renderMaskToTexture = !(mask instanceof Sprite);\n\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n\n        this.mask.measurable = false;\n    }\n\n    reset()\n    {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n\n    addBounds(bounds: Bounds, skipUpdateTransform?: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    containsPoint(point: PointData): boolean\n    {\n        const mask = this.mask as any;\n\n        if (mask.containsPoint)\n        {\n            return mask.containsPoint(point);\n        }\n\n        return false;\n    }\n\n    destroy(): void\n    {\n        this.reset();\n    }\n\n    static test(mask: any): boolean\n    {\n        return mask instanceof Sprite;\n    }\n}\n"],"names":[],"mappings":";;;;;AAYO,MAAM,SACb,CAAA;AAAA,EAQI,YAAY,OACZ,EAAA;AANA,IAAW,IAAA,CAAA,QAAA,GAAA,CAAA,CAAA;AAEX,IAAO,IAAA,CAAA,IAAA,GAAA,WAAA,CAAA;AAKH,IAAA,IAAI,SAAS,IACb,EAAA;AACI,MAAK,IAAA,CAAA,IAAA,CAAK,QAAQ,IAAI,CAAA,CAAA;AAAA,KAC1B;AAAA,GACJ;AAAA,EAEA,KAAK,IACL,EAAA;AACI,IAAA,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;AAIZ,IAAK,IAAA,CAAA,mBAAA,GAAsB,EAAE,IAAgB,YAAA,MAAA,CAAA,CAAA;AAE7C,IAAK,IAAA,CAAA,IAAA,CAAK,aAAa,IAAK,CAAA,mBAAA,CAAA;AAC5B,IAAK,IAAA,CAAA,IAAA,CAAK,cAAiB,GAAA,CAAC,IAAK,CAAA,mBAAA,CAAA;AAEjC,IAAA,IAAA,CAAK,KAAK,UAAa,GAAA,KAAA,CAAA;AAAA,GAC3B;AAAA,EAEA,KACA,GAAA;AACI,IAAA,IAAA,CAAK,KAAK,UAAa,GAAA,IAAA,CAAA;AACvB,IAAA,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;AAAA,GAChB;AAAA,EAEA,SAAA,CAAU,QAAgB,mBAC1B,EAAA;AACI,IAAc,aAAA,CAAA,IAAA,CAAK,IAAM,EAAA,MAAA,EAAQ,mBAAmB,CAAA,CAAA;AAAA,GACxD;AAAA,EAEA,cAAA,CAAe,QAAgB,SAC/B,EAAA;AACI,IAAmB,kBAAA,CAAA,IAAA,CAAK,IAAM,EAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;AAAA,GACnD;AAAA,EAEA,cAAc,KACd,EAAA;AACI,IAAA,MAAM,OAAO,IAAK,CAAA,IAAA,CAAA;AAElB,IAAA,IAAI,KAAK,aACT,EAAA;AACI,MAAO,OAAA,IAAA,CAAK,cAAc,KAAK,CAAA,CAAA;AAAA,KACnC;AAEA,IAAO,OAAA,KAAA,CAAA;AAAA,GACX;AAAA,EAEA,OACA,GAAA;AACI,IAAA,IAAA,CAAK,KAAM,EAAA,CAAA;AAAA,GACf;AAAA,EAEA,OAAO,KAAK,IACZ,EAAA;AACI,IAAA,OAAO,IAAgB,YAAA,MAAA,CAAA;AAAA,GAC3B;AACJ,CAAA;AApEa,SAAA,CAEF,YAA+B,aAAc,CAAA,UAAA;;;;"}