{"version":3,"file":"GlGeometrySystem.js","sources":["../../../../../src/rendering/renderers/gl/geometry/GlGeometrySystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { getGlInfoFromFormat } from './utils/getGlInfoFromFormat';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { GlProgram } from '../shader/GlProgram';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\nconst byteSizeMap: {[key: number]: number} = { 5126: 4, 5123: 2, 5121: 1 };\n\nconst topologyToGlMap = {\n    'point-list': 0x0000,\n    'line-list': 0x0001,\n    'line-strip': 0x0003,\n    'triangle-list': 0x0004,\n    'triangle-strip': 0x0005\n};\n\n/**\n * System plugin to the renderer to manage geometry.\n * @memberof PIXI\n */\n\nexport class GlGeometrySystem implements System\n{\n    /** @ignore */\n    static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'geometry',\n    } as const;\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    /**\n     * `true` if support `gl.UNSIGNED_INT` in `gl.drawElements` or `gl.drawElementsInstanced`.\n     * @readonly\n     */\n    public canUseUInt32ElementIndex: boolean;\n\n    protected gl: GlRenderingContext;\n    protected _activeGeometry: Geometry;\n    protected _activeVao: WebGLVertexArrayObject;\n\n    protected _geometryVaoHash: Record<number, Record<string, WebGLVertexArrayObject>> = {};\n\n    /** Cache for all geometries by id, used in case renderer gets destroyed or for profiling. */\n    readonly managedGeometries: {[key: number]: Geometry};\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private renderer: WebGLRenderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this.renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n        this.canUseUInt32ElementIndex = true;\n        this.managedGeometries = {};\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this.gl = this.renderer.gl;\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param program - Instance of program to use vao for.\n     */\n    bind(geometry?: Geometry, program?: GlProgram): void\n    {\n        // shader = shader || this.renderer.shader.shader;\n\n        const gl = this.gl;\n\n        this._activeGeometry = geometry;\n\n        const vao = this.getVao(geometry, program);\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            gl.bindVertexArray(vao);\n        }\n\n        // not sure the best way to address this..\n        // currently different shaders require different VAOs for the same geometry\n        // Still mulling over the best way to solve this one..\n        // will likely need to modify the shader attribute locations at run time!\n        // let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n        // let incRefCount = false;\n\n        // if (!vaos)\n        // {\n        //     this.managedGeometries[geometry.id] = geometry;\n        //     geometry.disposeRunner.add(this);\n        //     geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n        //     incRefCount = true;\n        // }\n\n        // const vao = vaos[program.id] || this.initGeometryVao(geometry, program, incRefCount);\n\n        // this._activeGeometry = geometry;\n\n        // if (this._activeVao !== vao)\n        // {\n        //     this._activeVao = vao;\n\n        //     if (this.hasVao)\n        //     {\n        //         gl.bindVertexArray(vao);\n        //     }\n        //     else\n        //     {\n        //         this.activateVao(geometry, shader.program);\n        //     }\n        // }\n\n        // // TODO - optimise later!\n        // // don't need to loop through if nothing changed!\n        // // maybe look to add an 'autoupdate' to geometry?\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    reset(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this.renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.updateBuffer(buffer);\n        }\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: GlProgram): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program.attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: GlProgram): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program.attributeData;\n\n        const strings = ['g', geometry.uid];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    getVao(geometry: Geometry, program: GlProgram): WebGLVertexArrayObject\n    {\n        return this._geometryVaoHash[geometry.uid]?.[program.key] || this.initGeometryVao(geometry, program);\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param program\n     * @param _incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, program: GlProgram, _incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this.renderer.gl;\n        // const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this.renderer.buffer;\n\n        this.renderer.shader.getProgramData(program);\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        if (!this._geometryVaoHash[geometry.uid])\n        {\n            this._geometryVaoHash[geometry.uid] = {};\n\n            geometry.on('destroy', this.onGeometryDestroy, this);\n        }\n\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program.key] = vao;\n\n            return vao;\n        }\n\n        const buffers = geometry.buffers;\n        const attributes = geometry.attributes;\n        const tempStride: Record<string, number> = {};\n        const tempStart: Record<string, number> = {};\n\n        for (const j in buffers)\n        {\n            tempStride[j] = 0;\n            tempStart[j] = 0;\n        }\n\n        for (const j in attributes)\n        {\n            if (!attributes[j].size && program.attributeData[j])\n            {\n                attributes[j].size = program.attributeData[j].size;\n            }\n            else if (!attributes[j].size)\n            {\n                console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`);  // eslint-disable-line\n            }\n\n            tempStride[attributes[j].buffer.uid] += attributes[j].size * byteSizeMap[attributes[j].type];\n        }\n\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const attribSize = attribute.size;\n\n            if (attribute.stride === undefined)\n            {\n                if (tempStride[attribute.buffer.uid] === attribSize * byteSizeMap[attribute.type])\n                {\n                    attribute.stride = 0;\n                }\n                else\n                {\n                    attribute.stride = tempStride[attribute.buffer.uid];\n                }\n            }\n\n            if (attribute.start === undefined)\n            {\n                attribute.start = tempStart[attribute.buffer.uid];\n\n                tempStart[attribute.buffer.uid] += attribSize * byteSizeMap[attribute.type];\n            }\n        }\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program.key] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n\n        return vao;\n    }\n\n    /**\n     * Disposes geometry.\n     * @param geometry - Geometry with buffers. Only VAO will be disposed\n     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    onGeometryDestroy(geometry: Geometry, contextLost?: boolean): void\n    {\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        const gl = this.gl;\n\n        if (vaoObjectHash)\n        {\n            if (contextLost)\n            {\n                for (const i in vaoObjectHash)\n                {\n                    if (this._activeVao !== vaoObjectHash[i])\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[i]);\n                }\n            }\n\n            this._geometryVaoHash[geometry.uid] = null;\n        }\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    destroyAll(contextLost = false): void\n    {\n        const gl = this.gl;\n\n        for (const i in this._geometryVaoHash)\n        {\n            if (contextLost)\n            {\n                for (const j in this._geometryVaoHash[i])\n                {\n                    const vaoObjectHash = this._geometryVaoHash[i];\n\n                    if (this._activeVao !== vaoObjectHash)\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[j]);\n                }\n            }\n\n            this._geometryVaoHash[i] = null;\n        }\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: GlProgram): void\n    {\n        const gl = this.renderer.gl;\n\n        const bufferSystem = this.renderer.buffer;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = attribute.buffer;\n            const glBuffer = bufferSystem.getGlBuffer(buffer);\n\n            if (program.attributeData[j])\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = program.attributeData[j].location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                const glInfo = getGlInfoFromFormat(attribute.format);\n\n                gl.vertexAttribPointer(location,\n                    glInfo.size,\n                    glInfo.type, // attribute.type || gl.FLOAT,\n                    glInfo.normalised,\n                    attribute.stride,\n                    attribute.offset);\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        gl.vertexAttribDivisor(location, 1);// attribute.divisor);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param topology - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     */\n    draw(topology?: Topology, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this.renderer;\n        const geometry = this._activeGeometry;\n\n        const glTopology = topologyToGlMap[geometry.topology || topology];\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (geometry.instanced)\n            {\n                /* eslint-disable max-len */\n                gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, geometry.instanceCount || 1);\n                /* eslint-enable max-len */\n            }\n            else\n            {\n                /* eslint-disable max-len */\n                gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n                /* eslint-enable max-len */\n            }\n        }\n        else if (geometry.instanced)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(glTopology, start, size || geometry.getSize(), instanceCount || 1);\n        }\n        else\n        {\n            gl.drawArrays(glTopology, start, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n"],"names":["getGlInfoFromFormat","ExtensionType"],"mappings":"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"}