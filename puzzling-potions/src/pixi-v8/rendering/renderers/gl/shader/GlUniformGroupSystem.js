'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Extensions = require('../../../../extensions/Extensions.js');
var unsafeEvalSupported = require('../../../../utils/unsafeEvalSupported.js');
var generateUniformsSync = require('./program/generateUniformsSync.js');

class GlUniformGroupSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.destroyed = false;
    /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */
    this.cache = {};
    this.uniformGroupSyncHash = {};
    this.renderer = renderer;
    this.systemCheck();
    this.gl = null;
    this.cache = {};
  }
  /**
   * Overrideable function by `@pixi/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   */
  systemCheck() {
    if (!unsafeEvalSupported.unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }
  }
  contextChange(gl) {
    this.gl = gl;
  }
  /**
   * Uploads the uniforms values to the currently bound shader.
   * @param group - the uniforms values that be applied to the current shader
   * @param program
   * @param syncData
   * @param syncData.textureCount
   */
  updateUniformGroup(group, program, syncData) {
    const programData = this.renderer.shader.getProgramData(program);
    if (!group.isStatic || group.dirtyId !== programData.uniformDirtyGroups[group.uid]) {
      programData.uniformDirtyGroups[group.uid] = group.dirtyId;
      const syncFunc = this.getUniformSyncFunction(group, program);
      syncFunc(programData.uniformData, group.uniforms, this.renderer, syncData);
    }
  }
  /**
   * Overrideable by the @pixi/unsafe-eval package to use static syncUniforms instead.
   * @param group
   * @param program
   */
  getUniformSyncFunction(group, program) {
    return this.uniformGroupSyncHash[group.signature]?.[program.key] || this.createUniformSyncFunction(group, program);
  }
  createUniformSyncFunction(group, program) {
    const uniformGroupSyncHash = this.uniformGroupSyncHash[group.signature] || (this.uniformGroupSyncHash[group.signature] = {});
    const id = this.getSignature(group, program.uniformData, "u");
    if (!this.cache[id]) {
      this.cache[id] = generateUniformsSync.generateUniformsSync(group, program.uniformData);
    }
    uniformGroupSyncHash[program.key] = this.cache[id];
    return uniformGroupSyncHash[program.key];
  }
  /**
   * Takes a uniform group and data and generates a unique signature for them.
   * @param group - The uniform group to get signature of
   * @param group.uniforms
   * @param uniformData - Uniform information generated by the shader
   * @param preFix
   * @returns Unique signature of the uniform group
   */
  getSignature(group, uniformData, preFix) {
    const uniforms = group.uniforms;
    const strings = [`${preFix}-`];
    for (const i in uniforms) {
      strings.push(i);
      if (uniformData[i]) {
        strings.push(uniformData[i].type);
      }
    }
    return strings.join("-");
  }
  /** Destroys this System and removes all its textures. */
  destroy() {
    this.renderer = null;
    this.destroyed = true;
  }
}
/** @ignore */
GlUniformGroupSystem.extension = {
  type: [
    Extensions.ExtensionType.WebGLSystem
  ],
  name: "uniformGroup"
};

exports.GlUniformGroupSystem = GlUniformGroupSystem;
//# sourceMappingURL=GlUniformGroupSystem.js.map
