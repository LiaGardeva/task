{"version":3,"file":"GpuEncoderSystem.mjs","sources":["../../../../src/rendering/renderers/gpu/GpuEncoderSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { Bounds } from '../../scene/bounds/Bounds';\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { GpuRenderTarget } from './renderTarget/GpuRenderTarget';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\nexport class GpuEncoderSystem implements System\n{\n    /** @ignore */\n    static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'encoder',\n    } as const;\n\n    commandEncoder: GPUCommandEncoder;\n    renderPassEncoder: GPURenderPassEncoder;\n    commandFinished: Promise<void>;\n\n    private resolveCommandFinished: (value: void) => void;\n\n    private gpu: GPU;\n    private boundBindGroup: Record<number, BindGroup> = {};\n    private boundVertexBuffer: Record<number, Buffer> = {};\n    private boundIndexBuffer: Buffer;\n    private boundPipeline: GPURenderPipeline;\n\n    private renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this.renderer = renderer;\n    }\n\n    start(): void\n    {\n        this.commandFinished = new Promise((resolve) =>\n        {\n            this.resolveCommandFinished = resolve;\n        });\n\n        // generate a render pass description..\n        // create an encoder..\n        this.commandEncoder = this.renderer.gpu.device.createCommandEncoder();\n    }\n\n    beginRenderPass(renderTarget: RenderTarget, gpuRenderTarget: GpuRenderTarget)\n    {\n        // TODO we should not finish a render pass each time we bind\n        // for example filters - we would want to push / pop render targets\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n        }\n\n        this.clearCache();\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n\n        this.setViewport(renderTarget.viewport);\n    }\n\n    setViewport(viewport: Rectangle): void\n    {\n        this.renderPassEncoder.setViewport(\n            viewport.x,\n            viewport.y,\n            viewport.width,\n            viewport.height,\n            0, 1);\n    }\n\n    setScissor(bounds: Bounds): void\n    {\n        bounds.fit(this.renderer.renderTarget.renderTarget.viewport);\n\n        this.renderPassEncoder.setScissorRect(\n            bounds.minX,\n            bounds.minY,\n            bounds.width,\n            bounds.height\n        );\n    }\n\n    clearScissor(): void\n    {\n        const viewport = this.renderer.renderTarget.renderTarget.viewport;\n\n        this.renderPassEncoder.setScissorRect(\n            viewport.x,\n            viewport.y,\n            viewport.width,\n            viewport.height\n        );\n    }\n\n    setPipelineFromGeometryProgramAndState(geometry: Geometry, program: GpuProgram, state: any, topology?: Topology): void\n    {\n        const pipeline = this.renderer.pipeline.getPipeline(geometry, program, state, topology);\n\n        this.setPipeline(pipeline);\n    }\n\n    setPipeline(pipeline: GPURenderPipeline)\n    {\n        if (this.boundPipeline === pipeline) return;\n        this.boundPipeline = pipeline;\n\n        this.renderPassEncoder.setPipeline(pipeline);\n    }\n\n    setVertexBuffer(index: number, buffer: Buffer)\n    {\n        if (this.boundVertexBuffer[index] === buffer) return;\n\n        this.boundVertexBuffer[index] = buffer;\n\n        this.renderPassEncoder.setVertexBuffer(\n            index,\n            this.renderer.buffer.updateBuffer(buffer),\n        );\n    }\n\n    setIndexBuffer(buffer: Buffer)\n    {\n        if (this.boundIndexBuffer === buffer) return;\n\n        this.boundIndexBuffer = buffer;\n\n        this.renderPassEncoder.setIndexBuffer(\n            this.renderer.buffer.updateBuffer(buffer),\n            'uint32',\n        );\n    }\n\n    setBindGroup(index: number, bindGroup: BindGroup, program: GpuProgram)\n    {\n        if (this.boundBindGroup[index] === bindGroup) return;\n        this.boundBindGroup[index] = bindGroup;\n\n        // TODO or is dirty!\n        const gpuBindGroup = this.renderer.bindGroup.getBindGroup(bindGroup, program, index);\n\n        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n    }\n\n    setGeometry(geometry: Geometry)\n    {\n        for (const i in geometry.attributes)\n        {\n            const attribute = geometry.attributes[i];\n\n            this.setVertexBuffer(attribute.shaderLocation, attribute.buffer);\n        }\n\n        if (geometry.indexBuffer)\n        {\n            this.setIndexBuffer(geometry.indexBuffer);\n        }\n    }\n\n    setShaderBindGroups(shader: Shader, skipSync?: boolean)\n    {\n        for (const i in shader.groups)\n        {\n            const bindGroup = shader.groups[i] as BindGroup;\n\n            // update any uniforms?\n            if (!skipSync)\n            {\n                this.syncBindGroup(bindGroup);\n            }\n\n            this.setBindGroup(i as unknown as number, bindGroup, shader.gpuProgram);\n        }\n    }\n\n    syncBindGroup(bindGroup: BindGroup)\n    {\n        for (const j in bindGroup.resources)\n        {\n            const resource = bindGroup.resources[j];\n\n            if ((resource as UniformGroup).isUniformGroup)\n            {\n                this.renderer.uniformBuffer.updateUniformGroup(resource as UniformGroup);\n            }\n        }\n    }\n\n    draw(options: {\n        geometry: Geometry,\n        shader: Shader,\n        state?: State,\n        topology?: Topology,\n        size?: number,\n        start?: number,\n        instanceCount?: number\n        skipSync?: boolean,\n    })\n    {\n        const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n\n        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n        this.setGeometry(geometry);\n        this.setShaderBindGroups(shader, skipSync);\n\n        if (geometry.indexBuffer)\n        {\n            this.renderPassEncoder.drawIndexed(size || geometry.indexBuffer.data.length, instanceCount || 1, start || 0);\n        }\n        else\n        {\n            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || 1, start || 0);\n        }\n    }\n\n    finishRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n            this.renderPassEncoder = null;\n        }\n    }\n\n    postrender()\n    {\n        this.finishRenderPass();\n\n        this.gpu.device.queue.submit([this.commandEncoder.finish()]);\n\n        this.resolveCommandFinished();\n    }\n\n    // restores a render pass if finishRenderPass was called\n    // not optimised as really used for debugging!\n    // used when we want to stop drawing and log a texture..\n    restoreRenderPass()\n    {\n        const descriptor = this.renderer.renderTarget.getDescriptor(\n            this.renderer.renderTarget.renderTarget,\n            false,\n            [0, 0, 0, 1]\n        );\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n\n        const boundPipeline = this.boundPipeline;\n        const boundVertexBuffer = { ...this.boundVertexBuffer };\n        const boundIndexBuffer = this.boundIndexBuffer;\n        const boundBindGroup = { ...this.boundBindGroup };\n\n        this.clearCache();\n\n        const viewport = this.renderer.renderTarget.renderTarget.viewport;\n\n        this.renderPassEncoder.setViewport(\n            viewport.x,\n            viewport.y,\n            viewport.width,\n            viewport.height,\n            0, 1);\n\n        // reinstate the cache...\n\n        this.setPipeline(boundPipeline);\n\n        for (const i in boundVertexBuffer)\n        {\n            this.setVertexBuffer(i as unknown as number, boundVertexBuffer[i]);\n        }\n\n        for (const i in boundBindGroup)\n        {\n            this.setBindGroup(i as unknown as number, boundBindGroup[i], null);\n        }\n\n        this.setIndexBuffer(boundIndexBuffer);\n    }\n\n    clearCache()\n    {\n        for (let i = 0; i < 16; i++)\n        {\n            this.boundBindGroup[i] = null;\n            this.boundVertexBuffer[i] = null;\n        }\n\n        this.boundIndexBuffer = null;\n        this.boundPipeline = null;\n    }\n\n    destroy()\n    {\n        // boom!\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this.gpu = gpu;\n    }\n}\n"],"names":[],"mappings":"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"}