{"version":3,"file":"UniformGroup.js","sources":["../../../../../src/rendering/renderers/shared/shader/UniformGroup.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/explicit-member-accessibility */\nimport { generateUID } from '../texture/utils/generateUID';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\nimport type { UniformData } from './utils/createUBOElements';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\nexport type UniformGroupOptions = {\n    ubo?: boolean;\n    isStatic?: boolean;\n};\n\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    static DEFAULT: UniformGroupOptions = {\n        ubo: false,\n        isStatic: false,\n    };\n\n    readonly uid = generateUID();\n\n    resourceType = 'uniformGroup';\n    resourceId = this.uid;\n\n    uniformStructures: UNIFORMS;\n    uniforms: ExtractUniformObject<UNIFORMS>;\n\n    ubo: boolean;\n\n    buffer?: Buffer;\n\n    isStatic: boolean;\n    // to identify this as a uniform group\n    readonly isUniformGroup = true;\n\n    dirtyId = 0;\n\n    readonly signature: string;\n\n    _syncFunction?: (uniforms: UNIFORMS, data: Float32Array, offset: number) => void;\n\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.DEFAULT, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n\n            uniforms[i]\n            = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS]\n            ?? uniformData as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this.dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this.signature = Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-');\n    }\n\n    update(): void\n    {\n        this.dirtyId++;\n        // dispatch...\n    }\n}\n"],"names":["generateUID"],"mappings":";;;;;;AAmBO,MAAM,gBAAN,MACP;AAAA,EA4BI,WAAA,CAAY,mBAA6B,OACzC,EAAA;AAvBA,IAAA,IAAA,CAAS,MAAMA,uBAAY,EAAA,CAAA;AAE3B,IAAe,IAAA,CAAA,YAAA,GAAA,cAAA,CAAA;AACf,IAAA,IAAA,CAAA,UAAA,GAAa,IAAK,CAAA,GAAA,CAAA;AAWlB;AAAA,IAAA,IAAA,CAAS,cAAiB,GAAA,IAAA,CAAA;AAE1B,IAAU,IAAA,CAAA,OAAA,GAAA,CAAA,CAAA;AAQN,IAAA,OAAA,GAAU,EAAE,GAAG,aAAa,CAAA,OAAA,EAAS,GAAG,OAAQ,EAAA,CAAA;AAEhD,IAAA,IAAA,CAAK,iBAAoB,GAAA,iBAAA,CAAA;AAEzB,IAAA,MAAM,WAAW,EAAC,CAAA;AAElB,IAAA,KAAA,MAAW,KAAK,iBAChB,EAAA;AACI,MAAM,MAAA,WAAA,GAAc,kBAAkB,CAAC,CAAA,CAAA;AAEvC,MAAA,WAAA,CAAY,IAAO,GAAA,CAAA,CAAA;AACnB,MAAY,WAAA,CAAA,IAAA,GAAO,YAAY,IAAQ,IAAA,CAAA,CAAA;AAEvC,MAAS,QAAA,CAAA,CAAC,CACR,GAAA,WAAA,CAAY,KACX,IAAA,WAAA,CAAA;AAAA,KACP;AAEA,IAAA,IAAA,CAAK,QAAW,GAAA,QAAA,CAAA;AAEhB,IAAA,IAAA,CAAK,OAAU,GAAA,CAAA,CAAA;AACf,IAAA,IAAA,CAAK,MAAM,OAAQ,CAAA,GAAA,CAAA;AACnB,IAAA,IAAA,CAAK,WAAW,OAAQ,CAAA,QAAA,CAAA;AAExB,IAAA,IAAA,CAAK,SAAY,GAAA,MAAA,CAAO,IAAK,CAAA,QAAQ,CAAE,CAAA,GAAA;AAAA,MACnC,CAAC,CAAM,KAAA,CAAA,EAAG,CAAM,CAAA,CAAA,EAAA,iBAAA,CAAkB,CAAmC,CAAkB,CAAA,IAAA,CAAA,CAAA;AAAA,KAC3F,CAAE,KAAK,GAAG,CAAA,CAAA;AAAA,GACd;AAAA,EAEA,MACA,GAAA;AACI,IAAK,IAAA,CAAA,OAAA,EAAA,CAAA;AAAA,GAET;AACJ,CAAA,CAAA;AAjEO,IAAM,YAAN,GAAA,cAAA;AAAM,YAAA,CAEF,OAA+B,GAAA;AAAA,EAClC,GAAK,EAAA,KAAA;AAAA,EACL,QAAU,EAAA,KAAA;AACd,CAAA;;;;"}