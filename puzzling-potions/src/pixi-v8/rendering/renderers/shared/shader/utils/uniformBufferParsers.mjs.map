{"version":3,"file":"uniformBufferParsers.mjs","sources":["../../../../../../src/rendering/renderers/shared/shader/utils/uniformBufferParsers.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n// Parsers, each one of these will take a look at the type of shader property and uniform.\n// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.\n// Shader upload code is automagically generated with these parsers.\n// If no parser is valid then the default upload functions are used.\n// exposing Parsers means that custom upload logic can be added to pixi's shaders.\n// A good example would be a pixi rectangle can be directly set on a uniform.\n// If the shader sees it it knows how to upload the rectangle structure as a vec4\n// format is as follows:\n//\n// {\n//     test: (data, uniform) => {} <--- test is this code should be used for this uniform\n//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform\n//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the\n//                                         uniform to a uniform buffer\n// }\nimport type { Matrix } from '../../../../../maths/Matrix';\nimport type { PointLike } from '../../../../../maths/PointLike';\nimport type { Rectangle } from '../../../../../maths/shapes/Rectangle';\nimport type { UNIFORM_TYPES, UniformData } from './createUBOElements';\n\nexport interface UniformParser\n{\n    type: UNIFORM_TYPES;\n    test: (data: UniformData) => boolean;\n    code: (name: string) => string;\n}\n\nexport const uniformBufferParsers: UniformParser[] = [\n    // uploading pixi matrix object to mat3\n    {\n        type: 'mat3x3<f32>',\n        test: (data: UniformData): boolean =>\n            (data.value as Matrix).a !== undefined,\n        code: (name: string): string =>\n            `\n                var ${name}_matrix = uv.${name}.toArray(true);\n\n                data[offset] = ${name}_matrix[0];\n                data[offset+1] = ${name}_matrix[1];\n                data[offset+2] = ${name}_matrix[2];\n\n                data[offset + 4] = ${name}_matrix[3];\n                data[offset + 5] = ${name}_matrix[4];\n                data[offset + 6] = ${name}_matrix[5];\n\n                data[offset + 8] = ${name}_matrix[6];\n                data[offset + 9] = ${name}_matrix[7];\n                data[offset + 10] = ${name}_matrix[8];\n            `,\n    },\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData) =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Rectangle).width !== undefined,\n        code: (name: string): string =>\n            `\n                        v = uv.${name};\n\n                        data[offset] = v.x;\n                        data[offset+1] = v.y;\n                        data[offset+2] = v.width;\n                        data[offset+3] = v.height;\n                    `,\n    },\n    {\n        type: 'vec2<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec2<f32>' && data.size === 1 && (data.value as PointLike).x !== undefined,\n        code: (name: string): string =>\n            `\n                    v = uv.${name};\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                `,\n    },\n    // uploading a pixi point as a vec2 with caching layer\n    // {\n    //     test: (data: any, uniform: any): boolean =>\n    //         data.type === 'vec2' && data.size === 1 && uniform.x !== undefined,\n    //     code: (name: string): string =>\n    //         `\n    //             v = uv.${name};\n\n    //             data[offset] = v.x;\n    //             data[offset+1] = v.y;\n    //         `,\n    // },\n    // caching layer for a vec2\n    // {\n    //     test: (data: any): boolean =>\n    //         data.type === 'vec2' && data.size === 1,\n    //     code: (name: string): string =>\n    //         `\n    //             cv = ud[\"${name}\"].value;\n    //             v = uv[\"${name}\"];\n\n    //             if(cv[0] !== v[0] || cv[1] !== v[1])\n    //             {\n    //                 cv[0] = v[0];\n    //                 cv[1] = v[1];\n    //                 gl.uniform2f(ud[\"${name}\"].location, v[0], v[1]);\n    //             }\n    //         `,\n    // },\n    // upload a pixi rectangle as a vec4 with caching layer\n    // {\n    //     test: (data: any, uniform: any): boolean =>\n    //         data.type === 'vec4' && data.size === 1 && uniform.width !== undefined,\n    //     code: (name: string): string =>\n    //         `\n    //                 v = uv.${name};\n\n    //                 data[offset] = v.x;\n    //                 data[offset+1] = v.y;\n    //                 data[offset+2] = v.width;\n    //                 data[offset+3] = v.height;\n    //             `,\n    // },\n    // a caching layer for vec4 uploading\n    // {\n    //     test: (data: any): boolean =>\n    //         data.type === 'vec4' && data.size === 1,\n    //     code: (name: string): string =>\n    //         `\n    //             cv = ud[\"${name}\"].value;\n    //             v = uv[\"${name}\"];\n\n    //             if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    //             {\n    //                 cv[0] = v[0];\n    //                 cv[1] = v[1];\n    //                 cv[2] = v[2];\n    //                 cv[3] = v[3];\n\n    //                 gl.uniform4f(ud[\"${name}\"].location, v[0], v[1], v[2], v[3])\n    //             }`,\n    // },\n];\n\n"],"names":[],"mappings":"AA4BO,MAAM,oBAAwC,GAAA;AAAA;AAAA,EAEjD;AAAA,IACI,IAAM,EAAA,aAAA;AAAA,IACN,IAAM,EAAA,CAAC,IACF,KAAA,IAAA,CAAK,MAAiB,CAAM,KAAA,KAAA,CAAA;AAAA,IACjC,IAAA,EAAM,CAAC,IACH,KAAA,CAAA;AAAA,oBAAA,EACU,IAAoB,CAAA,aAAA,EAAA,IAAA,CAAA;AAAA;AAAA,+BAET,EAAA,IAAA,CAAA;AAAA,iCACE,EAAA,IAAA,CAAA;AAAA,iCACA,EAAA,IAAA,CAAA;AAAA;AAAA,mCAEE,EAAA,IAAA,CAAA;AAAA,mCACA,EAAA,IAAA,CAAA;AAAA,mCACA,EAAA,IAAA,CAAA;AAAA;AAAA,mCAEA,EAAA,IAAA,CAAA;AAAA,mCACA,EAAA,IAAA,CAAA;AAAA,oCACC,EAAA,IAAA,CAAA;AAAA,YAAA,CAAA;AAAA,GAElC;AAAA,EACA;AAAA,IACI,IAAM,EAAA,WAAA;AAAA,IACN,IAAA,EAAM,CAAC,IAAA,KACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAoB,KAAU,KAAA,KAAA,CAAA;AAAA,IACxF,IAAA,EAAM,CAAC,IACH,KAAA,CAAA;AAAA,+BACqB,EAAA,IAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAA,CAAA;AAAA,GAO7B;AAAA,EACA;AAAA,IACI,IAAM,EAAA,WAAA;AAAA,IACN,IAAA,EAAM,CAAC,IAAA,KACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAoB,CAAM,KAAA,KAAA,CAAA;AAAA,IACpF,IAAA,EAAM,CAAC,IACH,KAAA,CAAA;AAAA,2BACiB,EAAA,IAAA,CAAA;AAAA;AAAA;AAAA;AAAA,gBAAA,CAAA;AAAA,GAKzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+DJ;;;;"}