{"version":3,"file":"CanvasTextSystem.js","sources":["../../../../src/rendering/text/canvas/CanvasTextSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/pow2';\nimport { convertColorToNumber } from '../../../utils/color/convertColorToNumber';\nimport { hex2rgb } from '../../../utils/color/hex';\nimport { CanvasPool } from '../../renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../scene/bounds/Bounds';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../settings/adapter/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../settings/adapter/ICanvasRenderingContext2D';\nimport type { StrokeStyle } from '../../graphics/shared/GraphicsContext';\nimport type { System } from '../../renderers/shared/system/System';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\nimport type { TextStyle } from '../TextStyle';\n\nconst tempBounds = new Bounds();\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    getTexture(text: string, resolution: number, style: TextStyle, textKey: string)\n    {\n        if (this.activeTextures[textKey])\n        {\n            this.increaseReferenceCount(textKey);\n\n            return this.activeTextures[textKey].texture;\n        }\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        // add a red background\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const bounds = tempBounds;\n\n        bounds.minX = 0;\n        bounds.minY = 0;\n\n        bounds.maxX = (canvas.width / resolution) | 0;\n        bounds.maxY = (canvas.height / resolution) | 0;\n\n        const texture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            false\n        );\n\n        texture.source.type = 'image';\n        texture.source.resource = canvas;\n\n        texture.frameWidth = measured.width;\n        texture.frameHeight = measured.height;\n\n        texture.source.update();\n        texture.layout.updateUvs();\n\n        this.activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    increaseReferenceCount(textKey: string)\n    {\n        this.activeTextures[textKey].usageCount++;\n    }\n\n    decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this.activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n            TexturePool.returnTexture(activeTexture.texture);\n            activeTexture.texture.source.resource = null;\n            activeTexture.texture.source.type = 'unknown';\n\n            this.activeTextures[textKey] = null;\n        }\n    }\n\n    getReferenceCount(textKey: string)\n    {\n        return this.activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n\n        context.scale(resolution, resolution);\n\n        // context.fillStyle = 'red';\n        context.clearRect(0, 0, measured.width, measured.height);\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = convertColorToNumber(shadowOptions.color);\n\n                const rgb = hex2rgb(dropShadowColor);\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.globalAlpha = style._fill?.alpha ?? 1;\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n\n                if (style._stroke?.width)\n                {\n                    const strokeStyle = style._stroke;\n\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n                    context.lineWidth = strokeStyle.width;\n\n                    context.miterLimit = strokeStyle.miterLimit;\n                    context.lineJoin = strokeStyle.join;\n                    context.lineCap = strokeStyle.cap;\n                }\n\n                context.shadowColor = 'black';\n                context.shadowBlur = 0;\n                context.shadowOffsetX = 0;\n                context.shadowOffsetY = 0;\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = (style.stroke as StrokeStyle)?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    destroy(): void\n    {\n        // TODO: Destroy all the canvas elements\n    }\n}\n"],"names":["Bounds","CanvasTextMetrics","nextPow2","CanvasPool","TexturePool","fontStringFromTextStyle","convertColorToNumber","hex2rgb","getCanvasFillStyle","i","ExtensionType"],"mappings":"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"}