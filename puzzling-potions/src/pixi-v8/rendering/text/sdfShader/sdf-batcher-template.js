'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var programSrc = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\nstruct LocalUniforms {\n  color:vec4<f32>,\n  transformMatrix:mat3x3<f32>,\n  distance: f32\n}\n\n// struct DistanceUniforms {\n//   distance: f32,\n// }\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n%bindings%\n@group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n//@group(3) @binding(0) var<uniform> distanceUniforms : DistanceUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n    @location(2) @interpolate(flat) textureId : u32,\n  };\n\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n  @location(1) aUV : vec2<f32>,\n  @location(2) aColor : vec4<f32>,\n  @location(3) aTexture : f32,\n) -> VSOutput {\n\n  var  mvpMatrix = globalUniforms.projectionMatrix * globalUniforms.worldTransformMatrix * localUniforms.transformMatrix;\n\n  var  colorOut = aColor.bgra * localUniforms.color.rgba;\n\n  var alpha = vec4<f32>(\n    colorOut.a * globalUniforms.worldAlpha,\n    colorOut.a * globalUniforms.worldAlpha,\n    colorOut.a * globalUniforms.worldAlpha,\n    globalUniforms.worldAlpha\n  );\n\n  colorOut *= alpha;\n\n\n  return VSOutput(\n    vec4<f32>((mvpMatrix * vec3<f32>(aPosition, 1.0)).xy, 0.0, 1.0),\n    aUV,\n    colorOut,\n    u32(aTexture)\n  );\n};\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color:vec4<f32>,\n  @location(2) @interpolate(flat) textureId: u32,\n) -> @location(0) vec4<f32> {\n\n\n    var uvDx = dpdx(uv);\n    var uvDy = dpdy(uv);\n\n    var outColor:vec4<f32>;\n    \n    %forloop%\n  \n    var dist = outColor.r;\n\n    // MSDF\n  var median = outColor.r + outColor.g + outColor.b -\n      min(outColor.r, min(outColor.g, outColor.b)) -\n      max(outColor.r, max(outColor.g, outColor.b));\n  // SDF\n  median = min(median, outColor.a);\n\n  // on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\n  \n  var screenPxDistance = localUniforms.distance * (median - 0.5);\n  var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n  if (median < 0.01) {\n    alpha = 0.0;\n  } else if (median > 0.99) {\n    alpha = 1.0;\n  }\n\n  return vec4(color.rgb * alpha, alpha);\n};\n";

exports["default"] = programSrc;
//# sourceMappingURL=sdf-batcher-template.js.map
