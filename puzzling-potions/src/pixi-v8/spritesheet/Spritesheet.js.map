{"version":3,"file":"Spritesheet.js","sources":["../../src/spritesheet/Spritesheet.ts"],"sourcesContent":["import { Rectangle } from '../maths/shapes/Rectangle';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\n\nimport type { PointData } from '../maths/PointData';\nimport type { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { BindableTexture } from '../rendering/renderers/shared/texture/Texture';\nimport type { Dict } from '../utils/types';\n\n/**\n * Represents the JSON data for a spritesheet atlas.\n * @memberof PIXI\n */\nexport interface SpritesheetFrameData\n{\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    trimmed?: boolean;\n    rotated?: boolean;\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    spriteSourceSize?: {\n        x: number;\n        y: number;\n    };\n    anchor?: PointData;\n    // borders?: ITextureBorders;\n}\n\n/**\n * Atlas format.\n * @memberof PIXI\n */\nexport interface SpritesheetData\n{\n    frames: Dict<SpritesheetFrameData>;\n    animations?: Dict<string[]>;\n    meta: {\n        scale: string;\n        // eslint-disable-next-line camelcase\n        related_multi_packs?: string[];\n    };\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Here's an example of a sprite sheet JSON data file:\n * ```json\n * {\n *     \"frames\": {\n *         \"enemy1.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"enemy2.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"button.png\":\n *         {\n *             \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100},\n *             \"sourceSize\": {\"w\":100,\"h\":100},\n *             \"anchor\": {\"x\":0,\"y\":0},\n *             \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35}\n *         }\n *     },\n *\n *     \"animations\": {\n *         \"enemy\": [\"enemy1.png\",\"enemy2.png\"]\n *     },\n *\n *     \"meta\": {\n *         \"image\": \"sheet.png\",\n *         \"format\": \"RGBA8888\",\n *         \"size\": {\"w\":136,\"h\":102},\n *         \"scale\": \"1\"\n *     }\n * }\n * ```\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}), default 9-slice borders\n * (see {@link PIXI.Texture#defaultBorders}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n * @memberof PIXI\n */\nexport class Spritesheet\n{\n    /** The maximum number of Textures to build per process. */\n    static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet[] = [];\n\n    /** Reference to ths source texture. */\n    public textureSource: TextureSource;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link PIXI.Sprite|Sprite}:\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * new Sprite(sheet.textures['image.png']);\n     */\n    public textures: Dict<Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:\n     * @example\n     * import { AnimatedSprite } from 'pixi.js';\n     *\n     * new AnimatedSprite(sheet.animations['anim_name']);\n     */\n    public animations: Dict<Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: SpritesheetData;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: Dict<SpritesheetFrameData>;\n\n    /** Collection of frame names. */\n    private _frameKeys: string[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     */\n    constructor(texture: BindableTexture, data: SpritesheetData)\n    {\n        this._texture = texture instanceof Texture ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {};\n        this.animations = {};\n        this.data = data;\n\n        const metaResolution = parseFloat(data.meta.scale);\n\n        if (metaResolution)\n        {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        }\n        else\n        {\n            this.resolution = texture.source._resolution;\n        }\n\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     * @method PIXI.Spritesheet#parse\n     */\n    public parse(): Promise<Record<string, Texture>>\n    {\n        return new Promise((resolve) =>\n        {\n            this._callback = resolve;\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n\n                    trim.x /= this.textureSource.width;\n                    trim.y /= this.textureSource.height;\n                    trim.width /= this.textureSource.width;\n                    trim.height /= this.textureSource.height;\n                }\n\n                // normalise...\n                frame.x /= this.textureSource.width;\n                frame.y /= this.textureSource.height;\n                frame.width /= this.textureSource.width;\n                frame.height /= this.textureSource.height;\n\n                orig.x /= this.textureSource.width;\n                orig.y /= this.textureSource.height;\n                orig.width /= this.textureSource.width;\n                orig.height /= this.textureSource.height;\n\n                this.textures[i] = new Texture({\n                    source: this.textureSource,\n                    layout: {\n                        frame,\n                        orig,\n                        trim,\n                        rotate: data.rotated ? 2 : 0,\n                        defaultAnchor: data.anchor\n                        // TODO - add data.borders\n                    },\n                    label: i,\n                });\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n}\n"],"names":["Texture","Rectangle"],"mappings":"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"}